#### 23种设计模式：

[设计模式实战](https://designpatternsphp.readthedocs.io/zh_CN/latest/README.html )

[整理](https://learnku.com/docs/php-design-patterns/2018)

#####单例模式

[单例详解](https://juejin.im/post/5b742231e51d45666436d90b)

- **反面模式，建议使用依赖注入模式**

- 类型：创建类模式 

- **PHP缺点：**PHP语言是一种解释型的脚本语言，这种运行机制使得每个PHP页面被解释执行后，所有的相关资源都会被回收。也就是说，PHP在语言级别上没有办法让某个对象常驻内存，这和[asp.net](http://www.111cn.net/net/net.html)、Java等编译型是不同的，比如在Java中单例会一直存在于整个应用程序的生命周期里，变量是跨页面级的，真正可以做到这个实例在应用程序生命周期中的唯一性。然而在PHP中，所有的变量无论是全局变量还是类的静态成员，都是**页面级**的，**每次页面被执行时，都会重新建立新的对象，都会在页面执行完毕后被清空**，这样似乎PHP单例模式就没有什么意义了，所以PHP单例模式我觉得**只是针对单次页面级请求时出现多个应用场景并需要共享同一对象资源时是非常有意义的**。 

- 模式定义：作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类。 

- 特点：

  - 一个类只能有一个实例 
  - 它必须自行创建这个实例 
  - 它必须自行向整个系统提供这个实例 

- UML图

  ![img](https://iocaffcdn.phphub.org/uploads/images/201803/19/1/bVjGzeAlPV.png) 

- 单例模式的优点：

  - 提高程序运行的**安全性**，只可以通过已定的公共方法进行全局访问，且不必担心过多的数据库打开关闭的问题。
  - 避免了因创建多个连接导致的不必要资源浪费 ，垃圾回收机制仅需要对一个连接句柄进行操作 ，节省内存资源，对于频繁创建销毁的对象，可以提高系统性能。
  - 功能解耦，利于代码维护。
  - 比类操作更加灵活
  - 允许可变数目的实例（多例模式）

- 单例模式的缺点：

   - 在**多线程**的应用场合下必须小心使用。如果当唯一实例**尚未创建**时 ，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时**各自创建**了一个实例，这样就有两个实例被构造出来， 从而**违反了单例模式中实例唯一的原则**。解决这个问题的办法是为指示类是否已经实例化的变量提供一个**互斥锁**(虽然这样会降低效率)。

- 适用场景

  - 主要用于数据库应用，避免大量new  消耗内存资源和系统资源 ，还可以减少数据库连接。
  - 配置类，用来全局控制某些配置信息 ，保证对于配置文件的操作都是基于这个实例的 ，防止多次实例化类对配置文件进行修改。

- 饿汉式单例（**PHP不可用**）：在单例类被加载时候，就实例化一个对象交给自己的引用

  ```
  //这是饿汉单例模式 
  //不过在php里，不允许这么实用。所以我们主要是说PHP的懒汉式单例模式 
  
  class test {
      private static $_instance = new self();
  
      public static function getInstance(){
          return self::$_instance;
      }
  
      private function __construct(){
          //检查实例化
          echo "instance\n";
      }
  
  }
  $a = test::getInstance();
  var_dump($a);
  ```

- 懒汉式单例：在调用取得实例方法的时候才会实例化对象 

  ```
  <?php
  //懒汉式单例模式
  
  //懒汉式单例模式
  
  class test {
      private static $_instance;
  
      private function __construct(){
          //检查实例化
          echo "instance\n";
      }
  
      public function __clone(){
          die('Clone is not allowed.' . E_USER_ERROR);
      }
  
      public static function getInstance(){
          if(!self::$_instance){
              self::$_instance = new self();
          }
          return self::$_instance;
      }
      public function em(){
          return 'test!';
      }
  }
  
  $obj= test::getInstance();
  $test=$obj->em();
  var_dump($test);
  ```

##### 工厂模式

- 类型：创建型

###### 简单工厂模式

- **定义：**简单工厂模式（Simple Factory Pattern）:又称为静态工厂方法（Static Factory Method）模式，之所以可以这么说，是因为简单工厂模式是通过一个**静态方法来创建对象**的。它属于类创建型模式。在简单工厂模式中，可以**根据参数的不同返回返回不同类的实例**。**简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类**。

- **模式结构：**

  - Factory：工厂角色

    工厂角色负责实现创建所有的实例的内部逻辑。

  - Product:抽象产品角色

    抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口 

  - ConcreteProduct：具体产品角色 

    具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例 

- **特点**

  当你需要什么，**只需要传入一个正确的参数**，就可以获取你所需要的对象，而无须知道其创建细节。

- **优点：**

  - 可以使用户根据参数获得对应的类实例，**避免了直接实例化类，降低了耦合性** 
  - 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，**客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品**；简单工厂模式通过这种做法**实现了对责任的分割**，它提供了专门的工厂类用于创建对象。
  - 客户端无须知道所创建的具体产品类的类名，**只需要知道具体产品类所对应的参数**即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。
  - 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上**提高了系统的灵活性**。

- **缺点：**

  - 由于工厂类集中了所有产品创建逻辑，**一旦不能正常工作，整个系统都要受到影响**。
  - 使用简单工厂模式将会**增加系统中类的个数**，在一定程序上增加了系统的复杂度和理解难度，**对增加具体商品不友好**。
  - 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，**不利于系统的扩展和维护**。
  - 简单工厂模式对商品的生产过程（具体类的实例化）进行了封装，将它们放在一个工厂类中。但是，当我们想要增加新商品时，需要修改工厂类，增加 switch 中的一个 case（或者增加一个静态方法），**当商品的种类很多时，效率不高**。 
  - 简单工厂模式由于使用了静态工厂方法，造成工厂角色**无法形成基于继承的等级结构**。

- **适用环境**：

  - 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
  - **客户端**只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，**只需要知道类型所对应的参数**。

- **举例**

  ```
  <?php
  interface animals // 抽象产品角色
  {
  public function animal();
  }
  class Cat implements animals // 具体产品角色
  {
  public function animal()
  {
  return "猫猫";
  }
  }
  class Dog implements animals // 具体产品角色
  {
  public function animal()
  {
  return "狗狗";
  }
  }
  class Factory // 工厂角色
  {
  public static function createAnimal($param)
  {
  $result = null;
  switch($param)
  {
  case 'cat':
  $result = new Cat();
  break;
  case 'dog':
  $result = new Dog();
  break;
  }
  return $result;
  }
  }
  echo  Factory::createAnimal("cat")->animal(); // 猫猫
  echo  Factory::createAnimal("dog")->animal(); // 狗狗
  
  ```
###### 工厂方法模式

- **定义**：Factory Method Pattern ，又称为工厂模式，也叫虚拟构造器模式，多态工厂模式。在工厂方法模式中，**工厂父类**负责**定义创建产品对象的公共接口**，而**工厂子类**则负责**生成具体的产品对象**，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即**通过工厂子类来确定究竟应该实例化哪一个具体产品类** 。

- **结构**

  - Product：抽象产品

    ​	具体产品对象共有的父类或者接口 

  - ConcreteProduct：具体产品

    ​	实现抽象产品角色所定义的接口 

  - Factory：抽象工厂

    ​	它声明了工厂方法，该方法返回Product对象 

  - ConcreteFactory：具体工厂

    ​	实现抽象工厂接口 

- **优点**

  - 工厂方法模式可以允许系统在**不修改工厂角色的情况下引进新产品** 。克服了简单工厂模式对于增加具体商品的不友好 。例如，我们想要添加另外一种商品（花猫），只要**写一个生产花猫的工厂子类**就好，原有工厂对象不需要进行任何修改。 
  - 在工厂方法模式中，**工厂方法用来创建客户所需要的产品**，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，**无须关心创建细节**，甚至无须知道具体产品类的类名。
  - **基于工厂角色和产品角色的多态性设计是工厂方法模式的关键**。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为**所有的具体工厂类都具有同一抽象父类**。
  - 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要**添加一个具体工厂和具体产品**就可以了。这样，系统的可扩展性也就变得非常好，**完全符合“开闭原则”**。

- **缺点**

  - 重构已经存在的类会破坏客户端代码 
  - 如果工厂方法所在类的构造函数为私有，则工厂方法无法继续扩展，或者必须实现工厂方法所在类的全部依赖方法 。
  - 在**添加新产品**时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中**类的个数将成对增加**，在一定程度上增加了**系统的复杂度**，有更多的类需要编译和运行，会给系统带来一些**额外的开销**。
  - 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。

- **适用场景**

  - 一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。
  - 一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。
  - 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。

- **举例**

  ```
  <?php
  abstract class animals // 抽象产品类
  {
      abstract public function animal();
  }
  class Cat extends animals // 具体产品类
  {
      public function animal()
      {
          return "猫猫";
      }
  }
  class Dog extends animals // 具体产品类
  {
      public function animal()
      {
          return "狗狗";
      }
  }
  interface Factory   // 抽象工厂类, 将对象的创建抽象成一个接口
  {
      public function create();
  }
  class CatFactory implements Factory  // 继承工厂类, 用于实例化产品
  {
      public function create()
      {
          return new Cat();
      }
  }
  class DogFactory implements Factory  // 继承工厂类, 用于实例化产品
  {
      public function create()
      {
          return new Dog();
      }
  }
  
  class Client    // 具体操作类
  {
      public function test()
      {
          $catResult = new CatFactory();
          echo $catResult->create()->animal();
  
          $DogResult = new DogFactory();
          echo $DogResult->create()->animal();
      }
  }
  
  $lala = new Client();
  $lala->test(); //  猫猫狗狗
  
  ```

  

######抽象工厂模式

- **定义**

  提供一个创建一系列**相关或相互依赖对象的接口**，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式 。

  这个和工厂方法模式类似，我们不再只要一个汉堡，可能是4个汉堡2个鸡翅，我们还是对服务员说，服务员属于具体工厂，抽象产品就是麦当劳可卖的食物，具体产品是我们跟服务员要的食物。 

- **结构**

  - 抽象工厂(Abstract Factory)角色：它声明创建抽象产品对象的接口
  - 具体工厂(Concrete Factory)角色：实现创建产品对象的操作
  - 抽象产品(Abstract Product)角色：声明一类产品的接口
  - 具体产品(Concrete Product)角色：实现抽象产品角色所定义的接口

- **优点**

  - 分离了具体的类
  - 使**增加或替换产品**族变得容易
  - 有利于产品的一致性
  - 抽象工厂模式**隔离了具体类的生成**，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需**改变具体工厂的实例**，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现**高内聚低耦合的设计目的**，因此抽象工厂模式得到了广泛的应用。
  - 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终**只使用同一个产品族中的对象**。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。
  - 增加新的具体工厂和产品族很方便，**无须修改已有系统**，符合“开闭原则”。

- **缺点**

  - **难以支持新种类的产品**。这是因为AbstractFactory接口确定了可以被创建的产品集合。支持新各类的产品就需要扩展访工厂接口，从而导致AbstractFactory类及其所有子类的改变。 
  - 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。
  - 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。

- **适用环境**

  - 一个系统要独立于它的产品的创建、组合和表示时。
  - 一个系统要由多个产品系列中的一个来配置时。
  - 需要强调一系列相关的产品对象的设计以便进行联合使用时。
  - 提供一个产品类库，而只想显示它们的接口而不是实现时

- **举例**

  ```
  <?php
  //抽象工厂模式
  interface AnimalsFactory // 抽象工厂
  {
      public function createCat(); // 生产一尾猫
      public function createDog(); // 生产一头狗 -_-
  }
  
  abstract class Cat  // 猫抽象
  {
      abstract function getCat();
  }
  class ForeignCat extends Cat // 猫具体
  {
      public function getCat()
      {
          return "外国布偶猫".PHP_EOL;
      }
  }
  class ChineseCat extends Cat
  {
      public function getCat()
      {
          return "华夏猫".PHP_EOL;
      }
  }
  
  abstract class Dog
  {
      abstract function getDog();
  }
  class ChineseDog extends Dog
  {
      public function getDog()
      {
          return "中华国犬".PHP_EOL;
      }
  }
  class ForeignDog extends Dog
  {
      public function getDog()
      {
          return "外国哈士奇".PHP_EOL;
      }
  }
  
  class CreateChineseAnimalFactory implements AnimalsFactory
  {
      public function createCat()
      {
          return new ChineseCat();
      }
      public function createDog()
      {
          return new ChineseDog();
      }
  }
  class CreateForeignAnimalFactory implements AnimalsFactory
  {
      public function createCat()
      {
          return new ForeignCat();
      }
      public function createDog()
      {
          return new ForeignDog();
      }
  }
  
  $result = new CreateForeignAnimalFactory();
  $ForeignCat = $result->createCat();
  echo $ForeignCat->getCat(); // 布偶猫
  
  $ForeignDog = $result->createDog();
  echo $ForeignDog->getDog(); // 哈士奇
  
  ```

  

###### 区别

**工厂方法模式与简单工厂模式** 

- 工厂方法模式与简单工厂模式再结构上的不同不是很明显。工厂方法类的核心是一个抽象工厂类，而简单工厂模式把核心放在一个具体类上。
- 工厂方法模式之所以有一个别名叫多态性工厂模式是因为具体工厂类都有共同的接口，或者有共同的抽象父类。
- 当系统扩展需要添加新的产品对象时，仅仅需要添加一个具体对象以及一个具体工厂对象，原有工厂对象不需要进行任何修改，也不需要修改客户端，很好的符合了”开放－封闭”原则。而简单工厂模式在添加新产品对象后不得不修改工厂方法，扩展性不好。
- 工厂方法模式退化后可以演变成简单工厂模式。

**总结**

- 简单工厂模式(静态方法工厂模式) ： 用来生产同一等级结构中的任意产品。（不能增加新的产品）
- 工厂模式 ：用来生产同一等级结构中的固定产品。（支持增加任意产品）
- 抽象工厂 ：用来生产不同产品种类的全部产品。（不能增加新的产品，支持增加产品种类）
- 无论是简单工厂模式、工厂模式还是抽象工厂模式，它们本质上都是将不变的部分提取出来，将可变的部分留作接口，以达到最大程度上的复用。究竟用哪种设计模式更适合，这要根据具体的业务需求来决定。 

##### 观察者模式

- **模式动机：**Observer Pattern 建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，**发生改变的对象称为观察目标，而被通知的对象称为观察者**，一个观察目标可以对应多个观察者，而且这些**观察者之间没有相互联系**，可以根据需要增加和删除观察者，使得系统更**易于扩展**，这就是观察者模式的模式动机 

- **类型：**行为型。

- **定义：**它定义对象间的一种**一对多的依赖关系**，，使得每当一个对象状态发生改变时，其**相关依赖对象**皆得到**通知并被自动更新**。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。 

- **模式结构：**

  - Subject: 抽象目标

    ​	主题角色将所有对观察者对象的引用保存在一个集合中，每个主题可以有任意多个观察者。抽象主题提供了增加和删除观察者对象的接口。 

  - ConcreteSubject: 具体目标

    ​	存储相关状态到具体观察者对象，当具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个具体子类实现。 

  - Observer: 观察者

    ​	为所有的具体观察者定义一个接口，在观察的主题发生改变时更新自己。 

  - ConcreteObserver: 具体观察者

    ​	存储一个具体主题对象，存储相关状态，实现抽象观察者角色所要求的更新接口，以使得其自身状态和主题的状态保持一致。 

- **分析：**

  - 观察者模式描述了如何建立对象与对象之间的依赖关系，如何构造满足这种需求的系统。
  - 这一模式中的关键对象是观察目标和观察者，一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知。
  - 作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为发布-订阅(publishsubscribe)。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通

- **优点**

  - 观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。
  - 观察者模式在观察目标和观察者之间建立一个抽象的耦合，耦合较小。
  - 观察者模式支持广播通信。
  - 观察者模式符合“开闭原则”的要求。

- **缺点**

  - 如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
  - 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
  - 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

- **适用环境**

  - 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
  - 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
  - 一个对象必须通知其他对象，而并不知道这些对象是谁。
  - 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。
  - 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换句话说，你不希望这些对象是紧密耦合的。

- **举例**

  ```
  <?php
  /**
   * 观察者模式
   * @author: Mac
   * @date: 2012/02/22
   */
  
  
  class Paper{ /* 主题    */
      private $_observers = array();
  
      public function register($sub){ /*  注册观察者 */
          $this->_observers[] = $sub;
      }
  
  
      public function trigger(){  /*  外部统一访问    */
          if(!empty($this->_observers)){
              foreach($this->_observers as $observer){
                  $observer->update();
              }
          }
      }
  }
  
  /**
   * 观察者要实现的接口
   */
  interface Observerable{
      public function update();
  }
  
  class Subscriber implements Observerable{
      public function update(){
          echo "Callback\n";
      }
  }
  //下面是测试代码
  
  /*  测试    */
  $paper = new Paper();
  $paper->register(new Subscriber());
  //$paper->register(new Subscriber1());
  //$paper->register(new Subscriber2());
  $paper->trigger();
  ```

##### 策略模式

##### 适配器模式

#####外观模式

#####依赖注入模式

