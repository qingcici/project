#### 常用设计模式：

[设计模式实战](https://learnku.com/docs/php-design-patterns/2018 )

[整理](https://design-patterns.readthedocs.io/zh_CN/latest/index.html )

[设计模式简介](https://code-ken.github.io/2016/02/29/DesignPatternWithPHP-0/)

#####单例模式

[单例详解](https://juejin.im/post/5b742231e51d45666436d90b)

- **类型**：创建类模式 

- **反面模式，建议使用依赖注入模式**

- **PHP缺点：**PHP语言是一种解释型的脚本语言，这种运行机制使得每个PHP页面被解释执行后，所有的相关资源都会被回收。也就是说，PHP在语言级别上没有办法让某个对象常驻内存，这和[asp.net](http://www.111cn.net/net/net.html)、Java等编译型是不同的，比如在Java中单例会一直存在于整个应用程序的生命周期里，变量是跨页面级的，真正可以做到这个实例在应用程序生命周期中的唯一性。然而在PHP中，所有的变量无论是全局变量还是类的静态成员，都是**页面级**的，**每次页面被执行时，都会重新建立新的对象，都会在页面执行完毕后被清空**，这样似乎PHP单例模式就没有什么意义了，所以PHP单例模式我觉得**只是针对单次页面级请求时出现多个应用场景并需要共享同一对象资源时是非常有意义的**。 

- **模式动机**

   - 对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。
   - 如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。
   - 一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。

- **模式定义**：作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类。 

- **特点**：

  - 一个类只能有一个实例 
  - 它必须自行创建这个实例 
  - 它必须自行向整个系统提供这个实例 

- UML图

  ![img](https://iocaffcdn.phphub.org/uploads/images/201803/19/1/bVjGzeAlPV.png) 

- **优点：**

  - 提高程序运行的**安全性**，只可以通过已定的公共方法进行全局访问，且不必担心过多的数据库打开关闭的问题。
  - 避免了因创建多个连接导致的不必要资源浪费 ，垃圾回收机制仅需要对一个连接句柄进行操作 ，节省内存资源，对于频繁创建销毁的对象，可以提高系统性能。
  - 功能解耦，利于代码维护。
  - 比类操作更加灵活
  - 允许可变数目的实例（多例模式）

- **缺点：**

   - 在**多线程**的应用场合下必须小心使用。如果当唯一实例**尚未创建**时 ，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时**各自创建**了一个实例，这样就有两个实例被构造出来， 从而**违反了单例模式中实例唯一的原则**。解决这个问题的办法是为指示类是否已经实例化的变量提供一个**互斥锁**(虽然这样会降低效率)。

- **适用场景**

  - 主要用于数据库应用，避免大量new  消耗内存资源和系统资源 ，还可以减少数据库连接。
  - 配置类，用来全局控制某些配置信息 ，保证对于配置文件的操作都是基于这个实例的 ，防止多次实例化类对配置文件进行修改。

- 饿汉式单例（**PHP不可用**）：在单例类被加载时候，就实例化一个对象交给自己的引用

  ```
  //这是饿汉单例模式 
  //不过在php里，不允许这么实用。所以我们主要是说PHP的懒汉式单例模式 
  
  class test {
      private static $_instance = new self();
  
      public static function getInstance(){
          return self::$_instance;
      }
  
      private function __construct(){
          //检查实例化
          echo "instance\n";
      }
  
  }
  $a = test::getInstance();
  var_dump($a);
  ```

- 懒汉式单例：在调用取得实例方法的时候才会实例化对象 

  ```
  <?php
  //懒汉式单例模式
  
  //懒汉式单例模式
  
  class test {
      private static $_instance;
  
      private function __construct(){
          //检查实例化
          echo "instance\n";
      }
  
      public function __clone(){
          die('Clone is not allowed.' . E_USER_ERROR);
      }
  
      public static function getInstance(){
          if(!self::$_instance){
              self::$_instance = new self();
          }
          return self::$_instance;
      }
      public function em(){
          return 'test!';
      }
  }
  
  $obj= test::getInstance();
  $test=$obj->em();
  var_dump($test);
  ```

##### 工厂模式

- 类型：创建型

###### 简单工厂模式

- **模式动机**

  考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。 

- **定义：**

  简单工厂模式（Simple Factory Pattern）:又称为静态工厂方法（Static Factory Method）模式，之所以可以这么说，是因为简单工厂模式是通过一个**静态方法来创建对象**的。它属于类创建型模式。在简单工厂模式中，可以**根据参数的不同返回返回不同类的实例**。**简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类**。

- **模式结构：**

  - Factory：工厂角色

    工厂角色负责实现创建所有的实例的内部逻辑。

  - Product:抽象产品角色

    抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口 

  - ConcreteProduct：具体产品角色 

    具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例 

- **特点**

  当你需要什么，**只需要传入一个正确的参数**，就可以获取你所需要的对象，而无须知道其创建细节。

- **优点：**

  - 可以使用户根据参数获得对应的类实例，**避免了直接实例化类，降低了耦合性** 
  - 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，**客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品**；简单工厂模式通过这种做法**实现了对责任的分割**，它提供了专门的工厂类用于创建对象。
  - 客户端无须知道所创建的具体产品类的类名，**只需要知道具体产品类所对应的参数**即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。
  - 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上**提高了系统的灵活性**。

- **缺点：**

  - 由于工厂类集中了所有产品创建逻辑，**一旦不能正常工作，整个系统都要受到影响**。
  - 使用简单工厂模式将会**增加系统中类的个数**，在一定程序上增加了系统的复杂度和理解难度，**对增加具体商品不友好**。
  - 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，**不利于系统的扩展和维护**。
  - 简单工厂模式对商品的生产过程（具体类的实例化）进行了封装，将它们放在一个工厂类中。但是，当我们想要增加新商品时，需要修改工厂类，增加 switch 中的一个 case（或者增加一个静态方法），**当商品的种类很多时，效率不高**。 
  - 简单工厂模式由于使用了静态工厂方法，造成工厂角色**无法形成基于继承的等级结构**。

- **适用环境**：

  - 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
  - **客户端**只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，**只需要知道类型所对应的参数**。

- **举例**

  ```
  <?php
  interface animals // 抽象产品角色
  {
  public function animal();
  }
  class Cat implements animals // 具体产品角色
  {
  public function animal()
  {
  return "猫猫";
  }
  }
  class Dog implements animals // 具体产品角色
  {
  public function animal()
  {
  return "狗狗";
  }
  }
  class Factory // 工厂角色
  {
  public static function createAnimal($param)
  {
  $result = null;
  switch($param)
  {
  case 'cat':
  $result = new Cat();
  break;
  case 'dog':
  $result = new Dog();
  break;
  }
  return $result;
  }
  }
  echo  Factory::createAnimal("cat")->animal(); // 猫猫
  echo  Factory::createAnimal("dog")->animal(); // 狗狗
  
  ```
###### 工厂方法模式

- **模式动机**

  现在对该系统进行修改，不再设计一个按钮工厂类来统一负责所有产品的创建，而是将具体按钮的创建过程交给专门的工厂子类去完成，我们先定义一个抽象的按钮工厂类，再定义具体的工厂类来生成圆形按钮、矩形按钮、菱形按钮等，它们实现在抽象按钮工厂类中定义的方法。这种抽象化的结果使这种结构可以在不修改具体工厂类的情况下引进新的产品，如果出现新的按钮类型，只需要为这种新类型的按钮创建一个具体的工厂类就可以获得该新按钮的实例，这一特点无疑使得工厂方法模式具有超越简单工厂模式的优越性，更加符合“开闭原则”。 

- **定义**：Factory Method Pattern ，又称为工厂模式，也叫虚拟构造器模式，多态工厂模式。在工厂方法模式中，**工厂父类**负责**定义创建产品对象的公共接口**，而**工厂子类**则负责**生成具体的产品对象**，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即**通过工厂子类来确定究竟应该实例化哪一个具体产品类** 。

- **结构**

  - Product：抽象产品

    ​	具体产品对象共有的父类或者接口 

  - ConcreteProduct：具体产品

    ​	实现抽象产品角色所定义的接口 

  - Factory：抽象工厂

    ​	它声明了工厂方法，该方法返回Product对象 

  - ConcreteFactory：具体工厂

    ​	实现抽象工厂接口 

- **优点**

  - 工厂方法模式可以允许系统在**不修改工厂角色的情况下引进新产品** 。克服了简单工厂模式对于增加具体商品的不友好 。例如，我们想要添加另外一种商品（花猫），只要**写一个生产花猫的工厂子类**就好，原有工厂对象不需要进行任何修改。 
  - 在工厂方法模式中，**工厂方法用来创建客户所需要的产品**，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，**无须关心创建细节**，甚至无须知道具体产品类的类名。
  - **基于工厂角色和产品角色的多态性设计是工厂方法模式的关键**。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为**所有的具体工厂类都具有同一抽象父类**。
  - 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要**添加一个具体工厂和具体产品**就可以了。这样，系统的可扩展性也就变得非常好，**完全符合“开闭原则”**。

- **缺点**

  - 重构已经存在的类会破坏客户端代码 
  - 如果工厂方法所在类的构造函数为私有，则工厂方法无法继续扩展，或者必须实现工厂方法所在类的全部依赖方法 。
  - 在**添加新产品**时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中**类的个数将成对增加**，在一定程度上增加了**系统的复杂度**，有更多的类需要编译和运行，会给系统带来一些**额外的开销**。
  - 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。

- **适用场景**

  - 一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。
  - 一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。
  - 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。

- **举例**

  ```
  <?php
  abstract class animals // 抽象产品类
  {
      abstract public function animal();
  }
  class Cat extends animals // 具体产品类
  {
      public function animal()
      {
          return "猫猫";
      }
  }
  class Dog extends animals // 具体产品类
  {
      public function animal()
      {
          return "狗狗";
      }
  }
  interface Factory   // 抽象工厂类, 将对象的创建抽象成一个接口
  {
      public function create();
  }
  class CatFactory implements Factory  // 继承工厂类, 用于实例化产品
  {
      public function create()
      {
          return new Cat();
      }
  }
  class DogFactory implements Factory  // 继承工厂类, 用于实例化产品
  {
      public function create()
      {
          return new Dog();
      }
  }
  
  class Client    // 具体操作类
  {
      public function test()
      {
          $catResult = new CatFactory();
          echo $catResult->create()->animal();
  
          $DogResult = new DogFactory();
          echo $DogResult->create()->animal();
      }
  }
  
  $lala = new Client();
  $lala->test(); //  猫猫狗狗
  
  ```

  

######抽象工厂模式

- **模式动机**

  - 在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。但是有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。

    > 为了更清晰地理解工厂方法模式，需要先引入两个概念：
    >
    > - **产品等级结构** ：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。
    > - **产品族** ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。

  - 当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。

  - 抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。

  - 抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。

- **定义**

  提供一个创建一系列**相关或相互依赖对象的接口**，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式 。

  这个和工厂方法模式类似，我们不再只要一个汉堡，可能是4个汉堡2个鸡翅，我们还是对服务员说，服务员属于具体工厂，抽象产品就是麦当劳可卖的食物，具体产品是我们跟服务员要的食物。 

- **结构**

  - 抽象工厂(Abstract Factory)角色：它声明创建抽象产品对象的接口
  - 具体工厂(Concrete Factory)角色：实现创建产品对象的操作
  - 抽象产品(Abstract Product)角色：声明一类产品的接口
  - 具体产品(Concrete Product)角色：实现抽象产品角色所定义的接口

- **优点**

  - 分离了具体的类
  - 使**增加或替换产品**族变得容易
  - 有利于产品的一致性
  - 抽象工厂模式**隔离了具体类的生成**，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需**改变具体工厂的实例**，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现**高内聚低耦合的设计目的**，因此抽象工厂模式得到了广泛的应用。
  - 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终**只使用同一个产品族中的对象**。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。
  - 增加新的具体工厂和产品族很方便，**无须修改已有系统**，符合“开闭原则”。

- **缺点**

  - **难以支持新种类的产品**。这是因为AbstractFactory接口确定了可以被创建的产品集合。支持新各类的产品就需要扩展访工厂接口，从而导致AbstractFactory类及其所有子类的改变。 
  - 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。
  - 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。

- **适用环境**

  - 一个系统要独立于它的产品的创建、组合和表示时。
  - 一个系统要由多个产品系列中的一个来配置时。
  - 需要强调一系列相关的产品对象的设计以便进行联合使用时。
  - 提供一个产品类库，而只想显示它们的接口而不是实现时

- **举例**

  ```
  <?php
  //抽象工厂模式
  interface AnimalsFactory // 抽象工厂
  {
      public function createCat(); // 生产一尾猫
      public function createDog(); // 生产一头狗 -_-
  }
  
  abstract class Cat  // 猫抽象
  {
      abstract function getCat();
  }
  class ForeignCat extends Cat // 猫具体
  {
      public function getCat()
      {
          return "外国布偶猫".PHP_EOL;
      }
  }
  class ChineseCat extends Cat
  {
      public function getCat()
      {
          return "华夏猫".PHP_EOL;
      }
  }
  
  abstract class Dog
  {
      abstract function getDog();
  }
  class ChineseDog extends Dog
  {
      public function getDog()
      {
          return "中华国犬".PHP_EOL;
      }
  }
  class ForeignDog extends Dog
  {
      public function getDog()
      {
          return "外国哈士奇".PHP_EOL;
      }
  }
  
  class CreateChineseAnimalFactory implements AnimalsFactory
  {
      public function createCat()
      {
          return new ChineseCat();
      }
      public function createDog()
      {
          return new ChineseDog();
      }
  }
  class CreateForeignAnimalFactory implements AnimalsFactory
  {
      public function createCat()
      {
          return new ForeignCat();
      }
      public function createDog()
      {
          return new ForeignDog();
      }
  }
  
  $result = new CreateForeignAnimalFactory();
  $ForeignCat = $result->createCat();
  echo $ForeignCat->getCat(); // 布偶猫
  
  $ForeignDog = $result->createDog();
  echo $ForeignDog->getDog(); // 哈士奇
  
  ```

  

###### 区别

**工厂方法模式与简单工厂模式** 

- 工厂方法模式与简单工厂模式再结构上的不同不是很明显。工厂方法类的核心是一个抽象工厂类，而简单工厂模式把核心放在一个具体类上。
- 工厂方法模式之所以有一个别名叫多态性工厂模式是因为具体工厂类都有共同的接口，或者有共同的抽象父类。
- 当系统扩展需要添加新的产品对象时，仅仅需要添加一个具体对象以及一个具体工厂对象，原有工厂对象不需要进行任何修改，也不需要修改客户端，很好的符合了”开放－封闭”原则。而简单工厂模式在添加新产品对象后不得不修改工厂方法，扩展性不好。
- 工厂方法模式退化后可以演变成简单工厂模式。

**总结**

- 简单工厂模式(静态方法工厂模式) ： 用来生产同一等级结构中的任意产品。（不能增加新的产品）
- 工厂模式 ：用来生产同一等级结构中的固定产品。（支持增加任意产品）
- 抽象工厂 ：用来生产不同产品种类的全部产品。（不能增加新的产品，支持增加产品种类）
- 无论是简单工厂模式、工厂模式还是抽象工厂模式，它们本质上都是将不变的部分提取出来，将可变的部分留作接口，以达到最大程度上的复用。究竟用哪种设计模式更适合，这要根据具体的业务需求来决定。 

##### 观察者模式

- **类型：**行为型。

- **模式动机：**

  Observer Pattern 建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，**发生改变的对象称为观察目标，而被通知的对象称为观察者**，一个观察目标可以对应多个观察者，而且这些**观察者之间没有相互联系**，可以根据需要增加和删除观察者，使得系统更**易于扩展**，这就是观察者模式的模式动机 

- **定义：**

  它定义对象间的一种**一对多的依赖关系**，，使得每当一个对象状态发生改变时，其**相关依赖对象**皆得到**通知并被自动更新**。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。 

- **模式结构：**

  - Subject: 抽象目标

    ​	主题角色将所有对观察者对象的引用保存在一个集合中，每个主题可以有任意多个观察者。抽象主题提供了增加和删除观察者对象的接口。 

  - ConcreteSubject: 具体目标

    ​	存储相关状态到具体观察者对象，当具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个具体子类实现。 

  - Observer: 观察者

    ​	为所有的具体观察者定义一个接口，在观察的主题发生改变时更新自己。 

  - ConcreteObserver: 具体观察者

    ​	存储一个具体主题对象，存储相关状态，实现抽象观察者角色所要求的更新接口，以使得其自身状态和主题的状态保持一致。 

- **分析：**

  - 观察者模式描述了如何建立对象与对象之间的依赖关系，如何构造满足这种需求的系统。
  - 这一模式中的关键对象是观察目标和观察者，一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知。
  - 作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为发布-订阅(publishsubscribe)。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通
  - 在观察者模式中，会改变的是主题的状态以及观察者的数目。用这个模式，你可以改变依赖于主题状态的对象，却不必改变主题。——找出程序中会变化的方面，然后将其和固定不变的方面相分离!
  - 主题和观察者都使用接口:观察者利用主题的接口向主题注册，而主题利用观察者接口通知观察者。这样可以让两者之间运作正常，又同时具有松耦合的优点! ——针对接口编程，不针对实现编程!
  - 观察者模式利用“组合”将许多观察者组合进主题中。对象(观察者——主题)之间的这种关系不是通过继承产生的，而是在运行时利用组合的方式产生的。 ——多用组合，少用继承！

- **优点**

  - 观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。
  - 观察者模式在观察目标和观察者之间建立一个抽象的耦合，**降低了主题对象和观察者对象的耦合度** 。
  - 观察者模式支持**广播通信**。
  - 观察者模式符合“**开闭原则**”的要求。

- **缺点**

  - 如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会**花费很多时间**。
  - 如果在观察者和观察目标之间有**循环依赖**的话，观察目标会触发它们之间进行循环调用，可能导致**系统崩溃**。
  - 观察者模式**没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的**，而仅仅只是知道观察目标发生了变化。

- **适用环境**

  - 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
  - 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
  - 一个对象必须通知其他对象，而并不知道这些对象是谁。
  - 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。
  - 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换句话说，你不希望这些对象是紧密耦合的。

- **举例**

  ```
  <?php
  /**
   * 观察者模式
   * @author: Mac
   * @date: 2012/02/22
   */
  
  
  class Paper{ /* 主题    */
      private $_observers = array();
  
      public function register($sub){ /*  注册观察者 */
          $this->_observers[] = $sub;
      }
  
  
      public function trigger(){  /*  外部统一访问    */
          if(!empty($this->_observers)){
              foreach($this->_observers as $observer){
                  $observer->update();
              }
          }
      }
  }
  
  /**
   * 观察者要实现的接口
   */
  interface Observerable{
      public function update();
  }
  
  class Subscriber implements Observerable{
      public function update(){
          echo "Callback\n";
      }
  }
  //下面是测试代码
  
  /*  测试    */
  $paper = new Paper();
  $paper->register(new Subscriber());
  //$paper->register(new Subscriber1());
  //$paper->register(new Subscriber2());
  $paper->trigger();
  ```

##### 策略模式

- **类型：**行为类模式
- **动机**
  - 完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。
  - 在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。
  - 在软件系统中，有许多算法可以实现某一功能，如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。
  - 除了提供专门的查找算法类之外，还可以在客户端程序中直接包含算法代码，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。
  - 为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类。

- **定义**

  **Strategy Pattern** ：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。 

   策略模式（Strategy Pattern ）是对算法的封装，把一系列的算法分别封装到对应的类中，并且这些类实现相同的接口，相互之间可以替换。在前面说过的行为类模式中，有一种模式也是关注对算法的封装——模版方法模式，对照类图可以看到，策略模式与模版方法模式的区别仅仅是多了一个单独的封装类Context，它与模版方法模式的区别在于：在模版方法模式中，调用算法的主体在抽象的父类中，而在策略模式中，调用算法的主体则是封装到了封装类Context中，抽象策略Strategy一般是一个接口，目的只是为了定义规范，里面一般不包含逻辑。其实，这只是通用实现，而在实际编程中，因为各个具体策略实现类之间难免存在一些相同的逻辑，为了避免重复的代码，我们常常使用抽象类来担任Strategy的角色，在里面封装公共的代码，因此，在很多应用的场景中，在策略模式中一般会看到模版方法模式的影子

- **结构**

  - 封装类：也叫上下文，对策略进行二次封装，目的是避免高层模块对策略的直接调用。
  - 抽象策略：通常情况下为一个接口，当各个实现类中存在着重复的逻辑时，则使用抽象类来封装这部分公共的代码，此时，策略模式看上去更像是模版方法模式。
  - 具体策略：具体策略角色通常由一组封装了算法的类来担任，这些类之间可以根据需要自由替换。

- **模式分析：**

  - 策略模式是一个比较容易理解和使用的设计模式，策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。
  - 在策略模式中，应当由客户端自己决定在什么情况下使用什么具体策略角色。
  - 策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中“退休”的方便，策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定。这在一定程度上提高了系统的灵活性，但是客户端需要理解所有具体策略类之间的区别，以便选择合适的算法，这也是策略模式的缺点之一，在一定程度上增加了客户端的使用难度。

- **优点**

  - 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。
  - 策略模式提供了管理相关的算法族的办法。
  - 策略模式提供了可以替换继承关系的办法。
  - 使用策略模式可以避免使用多重条件转移语句。

- **缺点**

  - 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。
  - 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。
  - 策略模式造成很多的策略类，每个具体策略类都会产生一个新类。有时候可以通过把依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以被不同客户端使用。换言之，可以使用享元模式来减少对象的数量。 

- **适用场景**

  - 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。
  - 一个系统需要动态地在几种算法中选择一种。
  - 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。
  - 不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。
  - 几个类的主要逻辑相同，只在部分逻辑的算法和行为上稍有区别的情况。
  - 有几种相似的行为，或者说算法，客户端需要动态地决定使用哪一种，那么可以使用策略模式，将这些算法封装起来供客户端调用。

- **代码**

  ```
  <?php
  header('Content-Type:text/html;charset=utf-8');
  /**
   * 策略模式演示代码
   *
   * 为了更好地突出“策略”，我们这里以出行为例演示，日常出行大概分为以下几种工具：自驾车，公交车，地铁，火车，飞机，轮船
   *
   * 下面一起看代码，领会何为策略模式
   */
  
  /**
   * Interface Travel 抽象策略角色
   * 约定具体方法
   */
  interface Travel
  {
      public function go();
  }
  
  /**
   * Class selfDriving 具体策略角色
   * 自驾车
   */
  class bySelfDriving implements Travel
  {
      public function go()
      {
          echo '我自己开着车出去玩<br>';
      }
  }
  
  /**
   * Class byBus具体策略角色
   * 乘公交
   */
  class byBus implements Travel {
      public function go()
      {
          echo '我乘公交出去玩<br>';
      }
  }
  
  /**
   * Class byMetro 具体策略角色
   * 乘地铁
   */
  class byMetro implements Travel
  {
      public function go()
      {
          echo '我乘地铁出去玩<br>';
      }
  }
  
  /**
   * Class byTrain 具体策略角色
   * 乘火车
   */
  class byTrain implements Travel
  {
      public function go()
      {
          echo '我乘火车出去玩<br>';
      }
  }
  
  /**
   * Class byAirplane 具体策略角色
   * 乘飞机
   */
  class byAirplane implements Travel
  {
      public function go()
      {
          echo '我乘飞机出去玩<br>';
      }
  }
  
  /**
   * Class bySteamship 具体策略角色
   * 乘轮船
   */
  class bySteamship implements Travel
  {
      public function go()
      {
          echo '我乘轮船出去玩<br>';
      }
  }
  
  /**
   * Class Mine 环境角色
   */
  class Mine{
      private $_strategy;
      private $_isChange = false;
  
      /**
       * 构造方法
       * 此处使用到了依赖注入和类型约束的概念，详情请参考
       * 1.聊一聊PHP的依赖注入(DI) 和 控制反转(IoC)
       * @link https://segmentfault.com/a/1190000007209266
       * 2.浅谈PHP的类型约束
       * @link https://segmentfault.com/a/1190000007226476
       *
       * @param Travel $travel
       */
      public function __construct(Travel $travel)
      {
          $this->_strategy = $travel;
      }
  
      /**
       * 改变出行方式
       *
       * @param Travel $travel
       */
      public function change(Travel $travel)
      {
          $this->_strategy = $travel;
          $this->_isChange = true;
      }
  
      public function goTravel()
      {
          if ($this->_isChange) {
              echo '现在改变主意，';
              $this->_strategy->go();
          } else {
              $this->_strategy->go();
          }
  
      }
  }
  
  /**
   * 客户端使用
   */
  $strategy = new Mine(new byBus());
  // 乘公交
  $strategy->goTravel();
  // 乘地铁
  $strategy->change(new byMetro());
  $strategy->goTravel();
  // 自驾车
  $strategy->change(new bySelfDriving());
  $strategy->goTravel();
  
  // 其他根据具体应用选择实现
  ```

##### 适配器模式

- **类型**：结构型模式
- **模式动机**
  - 在软件开发中采用类似于电源适配器的设计和编码技巧被称为适配器模式。
  - 通常情况下，客户端可以通过目标类的接口访问它所提供的服务。有时，现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的。
  - 在这种情况下，现有的接口需要转化为客户类期望的接口，这样保证了对现有类的重用。如果不进行这样的转化，客户类就不能利用现有类所提供的功能，适配器模式可以完成这样的转化。
  - 在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是适配器(Adapter)，它所包装的对象就是适配者(Adaptee)，即被适配的类。
  - 适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。
  - 简单来说，当你的实现和需要的接口，都无法修改的时候。 例如，你需要给甲方已有的系统做标准的兼容，标准不可修改，甲方的系统也不可修改，这个时候你就需要适配器的设计模式了。 对于web编程来说，将你现有的实现，和三方库结合起来，就需要使用适配器模式 

- **模式定义**

  - 适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 
  - 系统需要使用现有的类，而这些类的接口不符合系统的需要。
  - 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。

- **结构**

  - Target：目标抽象类
  - Adapter：适配器类
  - Adaptee：适配者类
  - Client：客户类

- **分析**

  ```
  这就好比你家墙上有一个电源三相插孔，但是插孔的孔距之间太小。你的电器三相插头插脚距太大的插不进去，或许你还有个两相的插头，或许你还有条USB线和type-C线，这些都没法插到三相接口里。于是你买了个插脚适合插到你墙上的排插，然后这个排插是这些年新出的，USB也能插。于是你把你的三相插头，两相插头，USB线，type-c线都插到排插上。实际上就是间接地连在了你墙壁上的三相插孔上。
  ```

- **优点**

  -  通过适配器，客户端可以调用同一接口，因而对客户端来说是透明的。这样做更简单、更直接、更紧凑。
  -  复用了现存的类，解决了现存类和复用环境要求不一致的问题。
  -  将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码。 
  - 一个对象适配器可以把多个不同的适配者类适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。 
  - 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。
  - 增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。
  - 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。

- **缺点**

  - 过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 

  - 类适配器模式的缺点如下：

    对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类和它的子类都适配到目标接口。

  - 对象适配器模式的缺点如下：

    与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。

- **使用场景**

  - 系统需要使用现有的类，而这些类的接口不符合系统的需要。
  - 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。

- **代码**

  ```
  <?php
  namespace Adapter;
  
  class Adaptee
  {
      static function sendParams()
      {
          return array(
              "tb" => "淘宝",
              "tm" => "天猫",
              "jd" => "京东",
          );
      }
  }
  
  class Adapter extends Adaptee
  {
      static function sendParams()
      {
          $params = parent::sendParams();
          $params = json_encode($params);
          return $params;
      }
  }
  
  
  header("Content-type:text/html;charset = utf-8");
  
  //=====客户端1======
  
  $client1 = Adaptee::sendParams();
  echo "tb => " . $client1['tb'] . "<br />";
  echo "tm => " . $client1['tm'] . "<br />";
  echo "jd => " . $client1['jd'] . "<br />";
  
  //=====客户端1======
  
  $client2 = Adapter::sendParams();
  $client2 = json_decode($client2);
  echo "tb => " . $client2->tb . "<br />";
  echo "tm => " . $client2->tm . "<br />";
  echo "jd => " . $client2->jd . "<br />";
  ```

#####外观模式

[详解](https://juejin.im/post/5a744dde5188257a71684294#heading-8)

[详解二](https://juejin.im/post/5ae2a019f265da0b736d5f46)

[详解三](https://blog.csdn.net/carson_ho/article/details/54910625)

- **类型**：结构型

- **定义**

  外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。 

  外观模式，也叫门面模式。它多用于在多个子系统之间，作为中间层。用户通过Facade对象，直接请求工作，省去了用户调用多个子系统的复杂动作。 

- **例子**

  外观模式常举的一个例子，就是我们买了好多支股票，但是时间有限。盯盘很复杂，我们搞得一团糟。所以，我们干脆买了股票基金。股票基金就好比于外观模式的Facade对象，而子系统就是股票基金投的各支股票。 

- **模式结构**

  - Facade: 外观角色
  - SubSystem:子系统角色

- **模式分析**

  根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。 -外观模式也是“迪米特法则”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。 - 外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。 -外观模式的目的在于降低系统的复杂程度。 -外观模式从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。 

- **优点**

  - 对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。
  - 实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。
  - 降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。
  - 只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。
  - 能够使你的终端调用与背后的子系统逻辑解耦，这往往发生在你的controller里，就意味着你的controller可以有更少的依赖，controller关注的更少了，从而责任和逻辑也更明确了，同时也意味着你子系统里的逻辑更改，并不会影响到你的controller里终端调用。

- **缺点**

  - 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。
  - 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。
  - 虽然特别有用，但是一个常见的陷阱就是，过度使用这个模式，明明可能那个时候你并不需要，这个往往注意即可。当然也有人争论说，明明我原来的代码都能用，干嘛费这个劲，那么同样是房子，你是喜欢住在精致的屋子里呢，还是说有四面墙就行了呢？ 

- **适用场景**

  - 当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。
  - 客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。
  - 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。

- **模式扩展**

  - 一个系统有多个外观类

    ​	在外观模式中，通常只需要一个外观类，并且此外观类只有一个实例，换言之它是一个单例类。在很多情况下为了节约系统资源，一般将外观类设计为单例类。当然这并不意味着在整个系统里只能有一个外观类，在一个系统中可以设计多个外观类，每个外观类都负责和一些特定的子系统交互，向用户提供相应的业务功能。

  - 不要试图通过外观类为子系统增加新行为

    ​	不要通过继承一个外观类在子系统中加入新的行为，这种做法是错误的。外观模式的用意是为子系统提供一个集中化和简化的沟通渠道，而不是向子系统加入新的行为，新的行为的增加应该通过修改原有子系统类或增加新的子系统类来实现，不能通过外观类来实现。

  - 外观模式与迪米特法则

    ​	外观模式创造出一个外观对象，将客户端所涉及的属于一个子系统的协作伙伴的数量减到最少，使得客户端与子系统内部的对象的相互作用被外观对象所取代。外观类充当了客户类与子系统类之间的“第三者”，降低了客户类与子系统类之间的耦合度，外观模式就是实现代码重构以便达到“迪米特法则”要求的一个强有力的武器。

  - 抽象外观类的引入

    ​	外观模式最大的缺点在于违背了“开闭原则”，当增加新的子系统或者移除子系统时需要修改外观类，可以通过引入抽象外观类在一定程度上解决该问题，客户端针对抽象外观类进行编程。对于新的业务需求，不修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改源代码并更换外观类的目的。

- **代码**

  ```
  <?php
  //医院医生员工系统
  class DoctorSystem{
  
      //通知就诊医生
      static public function getDoctor($name){
          echo __CLASS__.":".$name."医生，挂你号".PHP_EOL;
          return new Doctor($name);
      }
  }
  //医生类
  class Doctor{
      public $name;
      public function __construct($name){
          $this->name = $name;
      }
      public function prescribe($data){
          echo __CLASS__.":"."开个处方给你".PHP_EOL;
          return "祖传秘方，药到必死";
      }
  }
  //患者系统
  class SufferSystem {
      static function getData($suffer){
          $data = $suffer."资料";
          echo  __CLASS__.":".$suffer."的资料是这些".PHP_EOL ;
          return  $data;
      }
  }
  //医药系统
  class MedicineSystem {
      static function register($prescribe){
          echo __CLASS__.":"."拿到处方：".$prescribe."------------通知药房发药了".PHP_EOL;
          Shop::setMedicine("砒霜5千克");
      }
  }
  //药房
  class shop{
      static public $medicine;
      static function setMedicine($medicine){
          self::$medicine = $medicine;
      }
      static function getMedicine(){
          echo __CLASS__.":".self::$medicine.PHP_EOL;
      }
  }
  
  //如果没有挂号系统，我们就诊的第一步
  //通知就诊医生
  $doct = DoctorSystem::getDoctor("顾夕衣");
  //患者系统拿病历资料
  $data = SufferSystem::getData("何在");
  //医生看病历资料，开处方
  $prscirbe = $doct->prescribe($data);
  //医药系统登记处方
  MedicineSystem::register($prscirbe);
  //药房拿药
  Shop::getMedicine();
  
  echo PHP_EOL.PHP_EOL."--------有了挂号系统以后--------".PHP_EOL.PHP_EOL;
  
  //挂号系统
  class Facade{
      static public function regist($suffer,$doct){
          $doct = DoctorSystem::getDoctor($doct);
          //患者系统拿病历资料
          $data = SufferSystem::getData($suffer);
          //医生看病历资料，开处方
          $prscirbe = $doct->prescribe($data);
          //医药系统登记处方
          MedicineSystem::register($prscirbe);
          //药房拿药
          Shop::getMedicine();
      }
  }
  //患者只需要挂一个号，其他的就让挂号系统去做吧。
  Facade::regist("叶好龙","贾中一");
  ```

#####依赖注入模式

- **模式定义**

  依赖注入（Dependency Injection）是控制反转（Inversion of Control）的一种实现方式。

  我们先来看看什么是控制反转。

  当调用者需要被调用者的协助时，在传统的程序设计过程中，通常由调用者来创建被调用者的实例，但在这里，创建被调用者的工作不再由调用者来完成，而是将被调用者的创建移到调用者的外部，从而反转被调用者的创建，消除了调用者对被调用者创建的控制，因此称为控制反转。

  要实现控制反转，通常的解决方案是将创建被调用者实例的工作交由 IoC 容器来完成，然后在调用者中注入被调用者（通过构造器/方法注入实现），这样我们就实现了调用者与被调用者的解耦，该过程被称为依赖注入。

  依赖注入不是目的，它是一系列工具和手段，最终的目的是帮助我们开发出松散耦合（loose coupled）、可维护、可测试的代码和程序。这条原则的做法是大家熟知的面向接口，或者说是面向抽象编程。